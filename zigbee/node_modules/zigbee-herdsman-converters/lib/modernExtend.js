"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.actionEnumLookup = exports.binary = exports.numeric = exports.enumLookup = exports.light = exports.electricityMeter = exports.onOff = void 0;
const toZigbee_1 = __importDefault(require("../converters/toZigbee"));
const fromZigbee_1 = __importDefault(require("../converters/fromZigbee"));
const exposes_1 = require("./exposes");
const light_1 = require("./light");
const utils_1 = require("./utils");
const constants_1 = require("./constants");
const DefaultReportingItemValues = {
    minimumReportInterval: 0,
    maximumReportInterval: constants_1.repInterval.MAX,
    reportableChange: 1,
};
function getEndpointsWithInputCluster(device, cluster) {
    if (!device.endpoints) {
        throw new Error(device.ieeeAddr + ' ' + device.endpoints);
    }
    const endpoints = device.endpoints.filter((ep) => ep.getInputClusters().find((c) => c.name === cluster));
    if (endpoints.length === 0) {
        throw new Error(`Device ${device.ieeeAddr} has no input cluster ${cluster}`);
    }
    return endpoints;
}
async function setupAttributes(entity, coordinatorEndpoint, cluster, attributes, logger, readOnly = false) {
    const endpoints = (0, utils_1.isEndpoint)(entity) ? [entity] : getEndpointsWithInputCluster(entity, cluster);
    const ieeeAddr = (0, utils_1.isEndpoint)(entity) ? entity.deviceIeeeAddress : entity.ieeeAddr;
    for (const endpoint of endpoints) {
        const msg = readOnly ? `Reading` : `Reading and setup reporting`;
        logger.debug(`${msg} for ${ieeeAddr}/${endpoint.ID} ${cluster} ${JSON.stringify(attributes)}`);
        const items = attributes.map((attribute) => ({ ...DefaultReportingItemValues, ...((0, utils_1.isString)(attribute) ? { attribute } : attribute) }));
        if (!readOnly) {
            await endpoint.bind(cluster, coordinatorEndpoint);
            await endpoint.configureReporting(cluster, items);
        }
        await endpoint.read(cluster, attributes.map((a) => (0, utils_1.isString)(a) ? a : ((0, utils_1.isObject)(a.attribute) ? a.attribute.ID : a.attribute)));
    }
}
function onOff(args) {
    args = { powerOnBehavior: true, ...args };
    const exposes = [exposes_1.presets.switch()];
    const fromZigbee = [fromZigbee_1.default.on_off];
    const toZigbee = [toZigbee_1.default.on_off];
    const configure = async (device, coordinatorEndpoint, logger) => {
        await setupAttributes(device, coordinatorEndpoint, 'genOnOff', ['onOff'], logger);
        if (args.powerOnBehavior) {
            await setupAttributes(device, coordinatorEndpoint, 'genOnOff', ['startUpOnOff'], logger, true);
        }
    };
    if (args.powerOnBehavior) {
        exposes.push(exposes_1.presets.power_on_behavior(['off', 'on', 'toggle', 'previous']));
        fromZigbee.push(fromZigbee_1.default.power_on_behavior);
        toZigbee.push(toZigbee_1.default.power_on_behavior);
    }
    return { exposes, fromZigbee, toZigbee, configure, isModernExtend: true };
}
exports.onOff = onOff;
function electricityMeter(args) {
    var _a, _b, _c, _d;
    args = { cluster: 'both', ...args };
    if (args.cluster === 'metering' && (((_a = args.power) === null || _a === void 0 ? void 0 : _a.divisor) !== ((_b = args.energy) === null || _b === void 0 ? void 0 : _b.divisor) || ((_c = args.power) === null || _c === void 0 ? void 0 : _c.multiplier) !== ((_d = args.energy) === null || _d === void 0 ? void 0 : _d.multiplier))) {
        throw new Error(`When cluster is metering, power and energy divisor/multiplier should be equal`);
    }
    let exposes;
    let fromZigbee;
    let toZigbee;
    const configureLookup = {
        haElectricalMeasurement: {
            // Report change with every 5W change
            power: { attribute: 'activePower', divisor: 'acPowerDivisor', multiplier: 'acPowerMultiplier', forced: args.power, change: 5 },
            // Report change with every 0.05A change
            current: { attribute: 'rmsCurrent', divisor: 'acCurrentDivisor', multiplier: 'acCurrentMultiplier', forced: args.current, change: 0.05 },
            // Report change with every 5V change
            voltage: { attribute: 'rmsVoltage', divisor: 'acVoltageDivisor', multiplier: 'acVoltageMultiplier', forced: args.voltage, change: 5 },
        },
        seMetering: {
            // Report change with every 5W change
            power: { attribute: 'instantaneousDemand', divisor: 'divisor', multiplier: 'multiplier', forced: args.power, change: 5 },
            // Report change with every 0.1kWh change
            energy: { attribute: 'currentSummDelivered', divisor: 'divisor', multiplier: 'multiplier', forced: args.energy, change: 0.1 },
        },
    };
    if (args.cluster === 'both') {
        exposes = [exposes_1.presets.power().withAccess(exposes_1.access.ALL), exposes_1.presets.voltage().withAccess(exposes_1.access.ALL), exposes_1.presets.current().withAccess(exposes_1.access.ALL), exposes_1.presets.energy().withAccess(exposes_1.access.ALL)];
        fromZigbee = [fromZigbee_1.default.electrical_measurement, fromZigbee_1.default.metering];
        toZigbee = [toZigbee_1.default.electrical_measurement_power, toZigbee_1.default.acvoltage, toZigbee_1.default.accurrent, toZigbee_1.default.currentsummdelivered];
        delete configureLookup.seMetering.power;
    }
    else if (args.cluster === 'metering') {
        exposes = [exposes_1.presets.power().withAccess(exposes_1.access.ALL), exposes_1.presets.energy().withAccess(exposes_1.access.ALL)];
        fromZigbee = [fromZigbee_1.default.metering];
        toZigbee = [toZigbee_1.default.metering_power, toZigbee_1.default.currentsummdelivered];
        delete configureLookup.haElectricalMeasurement;
    }
    else if (args.cluster === 'electrical') {
        exposes = [exposes_1.presets.power().withAccess(exposes_1.access.ALL), exposes_1.presets.voltage().withAccess(exposes_1.access.ALL), exposes_1.presets.current().withAccess(exposes_1.access.ALL)];
        fromZigbee = [fromZigbee_1.default.electrical_measurement];
        toZigbee = [toZigbee_1.default.electrical_measurement_power, toZigbee_1.default.acvoltage, toZigbee_1.default.accurrent];
        delete configureLookup.seMetering;
    }
    const configure = async (device, coordinatorEndpoint, logger) => {
        var _a, _b;
        for (const [cluster, properties] of Object.entries(configureLookup)) {
            for (const endpoint of getEndpointsWithInputCluster(device, cluster)) {
                const items = [];
                for (const property of Object.values(properties)) {
                    // In case multiplier or divisor was provided, use that instead of reading from device.
                    if (property.forced) {
                        endpoint.saveClusterAttributeKeyValue(cluster, {
                            [property.divisor]: (_a = property.forced.divisor) !== null && _a !== void 0 ? _a : 1,
                            [property.multiplier]: (_b = property.forced.multiplier) !== null && _b !== void 0 ? _b : 1,
                        });
                        endpoint.save();
                    }
                    else {
                        await endpoint.read(cluster, [property.divisor, property.multiplier]);
                    }
                    const divisor = endpoint.getClusterAttributeValue(cluster, property.divisor);
                    (0, utils_1.assertNumber)(divisor, property.divisor);
                    const multiplier = endpoint.getClusterAttributeValue(cluster, property.multiplier);
                    (0, utils_1.assertNumber)(multiplier, property.multiplier);
                    let reportableChange = property.change * (divisor / multiplier);
                    // currentSummDelivered data type is uint48, so reportableChange also is uint48
                    if (property.attribute === 'currentSummDelivered')
                        reportableChange = [0, reportableChange];
                    items.push({
                        attribute: property.attribute,
                        minimumReportInterval: constants_1.repInterval.SECONDS_10,
                        maximumReportInterval: constants_1.repInterval.MAX,
                        reportableChange,
                    });
                }
                await setupAttributes(endpoint, coordinatorEndpoint, cluster, items, logger);
            }
        }
    };
    return { exposes, fromZigbee, toZigbee, configure, isModernExtend: true };
}
exports.electricityMeter = electricityMeter;
function light(args) {
    args = { effect: true, powerOnBehaviour: true, ...args };
    if (args.colorTemp) {
        args.colorTemp = { startup: true, ...args.colorTemp };
    }
    const argsColor = args.color ? false : { modes: ['xy'], ...((0, utils_1.isObject)(args.color) ? args.color : {}) };
    let lightExpose = exposes_1.presets.light().withBrightness();
    const fromZigbee = [fromZigbee_1.default.on_off, fromZigbee_1.default.brightness, fromZigbee_1.default.ignore_basic_report, fromZigbee_1.default.level_config];
    const toZigbee = [
        toZigbee_1.default.light_onoff_brightness, toZigbee_1.default.ignore_transition, toZigbee_1.default.level_config, toZigbee_1.default.ignore_rate, toZigbee_1.default.light_brightness_move, toZigbee_1.default.light_brightness_step,
    ];
    const meta = {};
    if (args.colorTemp || argsColor) {
        fromZigbee.push(fromZigbee_1.default.color_colortemp);
        toZigbee.push(toZigbee_1.default.light_color_colortemp, toZigbee_1.default.light_color_mode, toZigbee_1.default.light_color_options);
    }
    if (args.colorTemp) {
        lightExpose = lightExpose.withColorTemp(args.colorTemp.range);
        toZigbee.push(toZigbee_1.default.light_colortemp_move, toZigbee_1.default.light_colortemp_step);
        if (args.colorTemp.startup) {
            toZigbee.push(toZigbee_1.default.light_colortemp_startup);
            lightExpose = lightExpose.withColorTempStartup(args.colorTemp.range);
        }
    }
    if (argsColor) {
        lightExpose = lightExpose.withColor(argsColor.modes);
        toZigbee.push(toZigbee_1.default.light_hue_saturation_move, toZigbee_1.default.light_hue_saturation_step);
        if (argsColor.modes.includes('hs')) {
            meta.supportsHueAndSaturation = true;
        }
    }
    const exposes = [lightExpose];
    if (args.effect) {
        exposes.push(exposes_1.presets.effect());
        toZigbee.push(toZigbee_1.default.effect);
    }
    if (args.powerOnBehaviour) {
        exposes.push(exposes_1.presets.power_on_behavior(['off', 'on', 'toggle', 'previous']));
        fromZigbee.push(fromZigbee_1.default.power_on_behavior);
        toZigbee.push(toZigbee_1.default.power_on_behavior);
    }
    const configure = async (device, coordinatorEndpoint, logger) => {
        await (0, light_1.configure)(device, coordinatorEndpoint, logger, true);
    };
    return { exposes, fromZigbee, toZigbee, configure, isModernExtend: true };
}
exports.light = light;
function enumLookup(args) {
    const { name, lookup, cluster, attribute, description, zigbeeCommandOptions, endpoint, readOnly } = args;
    const attributeKey = (0, utils_1.isString)(attribute) ? attribute : attribute.id;
    let expose = exposes_1.presets.enum(name, readOnly ? exposes_1.access.STATE_GET : exposes_1.access.ALL, Object.keys(lookup)).withDescription(description);
    if (endpoint)
        expose = expose.withEndpoint(endpoint);
    const fromZigbee = [{
            cluster: cluster.toString(),
            type: ['attributeReport', 'readResponse'],
            convert: (model, msg, publish, options, meta) => {
                if (attributeKey in msg.data && (!endpoint || (0, utils_1.getEndpointName)(msg, model, meta) === endpoint)) {
                    return { [expose.property]: (0, utils_1.getFromLookupByValue)(msg.data[attributeKey], lookup) };
                }
            },
        }];
    const toZigbee = [{
            key: [name],
            convertSet: readOnly ? undefined : async (entity, key, value, meta) => {
                const payloadValue = (0, utils_1.getFromLookup)(value, lookup);
                const payload = (0, utils_1.isString)(attribute) ? { [attribute]: payloadValue } : { [attribute.id]: { value: payloadValue, type: attribute.type } };
                await entity.write(cluster, payload, zigbeeCommandOptions);
                return { state: { [key]: value } };
            },
            convertGet: async (entity, key, meta) => {
                await entity.read(cluster, [attributeKey], zigbeeCommandOptions);
            },
        }];
    return { exposes: [expose], fromZigbee, toZigbee, isModernExtend: true };
}
exports.enumLookup = enumLookup;
function numeric(args) {
    const { name, cluster, attribute, description, zigbeeCommandOptions, unit, readOnly, valueMax, valueMin, valueStep, endpoint, scale } = args;
    const attributeKey = (0, utils_1.isString)(attribute) ? attribute : attribute.id;
    let expose = exposes_1.presets.numeric(name, readOnly ? exposes_1.access.STATE_GET : exposes_1.access.ALL).withDescription(description);
    if (endpoint)
        expose = expose.withEndpoint(endpoint);
    if (unit)
        expose = expose.withUnit(unit);
    if (valueMin !== undefined)
        expose = expose.withValueMin(valueMin);
    if (valueMax !== undefined)
        expose = expose.withValueMax(valueMax);
    if (valueStep !== undefined)
        expose = expose.withValueStep(valueStep);
    const fromZigbee = [{
            cluster: cluster.toString(),
            type: ['attributeReport', 'readResponse'],
            convert: (model, msg, publish, options, meta) => {
                if (attributeKey in msg.data && (!endpoint || (0, utils_1.getEndpointName)(msg, model, meta) === endpoint)) {
                    let value = msg.data[attributeKey];
                    (0, utils_1.assertNumber)(value);
                    if (scale !== undefined)
                        value = value / scale;
                    return { [expose.property]: value };
                }
            },
        }];
    const toZigbee = [{
            key: [name],
            convertSet: readOnly ? undefined : async (entity, key, value, meta) => {
                (0, utils_1.assertNumber)(value, key);
                const payloadValue = scale === undefined ? value : value * scale;
                const payload = (0, utils_1.isString)(attribute) ? { [attribute]: payloadValue } : { [attribute.id]: { value: payloadValue, type: attribute.type } };
                await entity.write(cluster, payload, zigbeeCommandOptions);
                return { state: { [key]: value } };
            },
            convertGet: async (entity, key, meta) => {
                await entity.read(cluster, [attributeKey], zigbeeCommandOptions);
            },
        }];
    return { exposes: [expose], fromZigbee, toZigbee, isModernExtend: true };
}
exports.numeric = numeric;
function binary(args) {
    const { name, valueOn, valueOff, cluster, attribute, description, zigbeeCommandOptions, readOnly, endpoint } = args;
    const attributeKey = (0, utils_1.isString)(attribute) ? attribute : attribute.id;
    let expose = exposes_1.presets.binary(name, readOnly ? exposes_1.access.STATE_GET : exposes_1.access.ALL, valueOn[0], valueOff[0]).withDescription(description);
    if (endpoint)
        expose = expose.withEndpoint(endpoint);
    const fromZigbee = [{
            cluster: cluster.toString(),
            type: ['attributeReport', 'readResponse'],
            convert: (model, msg, publish, options, meta) => {
                if (attributeKey in msg.data && (!endpoint || (0, utils_1.getEndpointName)(msg, model, meta) === endpoint)) {
                    return { [expose.property]: msg.data[attributeKey] === valueOn[1] ? valueOn[0] : valueOff[0] };
                }
            },
        }];
    const toZigbee = [{
            key: [name],
            convertSet: readOnly ? undefined : async (entity, key, value, meta) => {
                const payloadValue = value === valueOn[0] ? valueOn[1] : valueOff[1];
                const payload = (0, utils_1.isString)(attribute) ? { [attribute]: payloadValue } : { [attribute.id]: { value: payloadValue, type: attribute.type } };
                await entity.write(cluster, payload, zigbeeCommandOptions);
                return { state: { [key]: value } };
            },
            convertGet: async (entity, key, meta) => {
                await entity.read(cluster, [attributeKey], zigbeeCommandOptions);
            },
        }];
    return { exposes: [expose], fromZigbee, toZigbee, isModernExtend: true };
}
exports.binary = binary;
function actionEnumLookup(args) {
    const { lookup, attribute, cluster } = args;
    const attributeKey = (0, utils_1.isString)(attribute) ? attribute : attribute.id;
    const expose = exposes_1.presets.enum('action', exposes_1.access.STATE, Object.keys(lookup)).withDescription('Triggered action (e.g. a button click)');
    const fromZigbee = [{
            cluster: cluster.toString(),
            type: ['attributeReport', 'readResponse'],
            convert: (model, msg, publish, options, meta) => {
                if (attributeKey in msg.data) {
                    let value = (0, utils_1.getFromLookupByValue)(msg.data[attributeKey], lookup);
                    if (args.postfixWithEndpointName)
                        value = (0, utils_1.postfixWithEndpointName)(value, msg, model, meta);
                    return { [expose.property]: value };
                }
            },
        }];
    return { exposes: [expose], fromZigbee, isModernExtend: true };
}
exports.actionEnumLookup = actionEnumLookup;
//# sourceMappingURL=modernExtend.js.map